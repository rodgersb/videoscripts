#!/bin/sh
# divxhtcheck: Runs a series of quality-assurance tests on a DivX AVI
#   file to ensure that it complies with the DivX Home Theatre profile.
# Copyright (C) 2012 Bryan Rodgers <rodgersb@it.net.au>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
# Note that you'll need the following installed on your system to run
# this script:
#   * MPlayer <http://mplayerhq.hu/>
#   * A POSIX-compatible bc implementation (GNU bc is also good)
#   * GNU coreutils <http://www.gnu.org/software/coreutils/>
#       (for the `mkfifo' command needed to create named pipes)

# Name of this script, used for displaying error messages.
PROGNAME="${0##*/}"

# List of MPlayer audio format codes for the ID_AUDIO_FORMAT variable
# returned by `mplayer -identify'.
AUDF_MPEG1_LAYER_II=80      # MPEG-1 Layer II
AUDF_MPEG1_LAYER_III=85     # MPEG-1 Layer III
AUDF_DOLBY_AC3=8192         # Dolby AC-3
# Codec string MPlayer uses to identify DIVX v3 video streams
VIDCODEC_DIVX3=ffdivx
# Codec string MPlayer uses to identify DIVX v5 video streams
VIDCODEC_DIVX5=ffodivx

# Warning message fragment that MPlayer produces if it plays a DivX
# video stream with non-standard bi-directional predictive frames (i.e.
# B-frames). The search string may need to be updated if the message
# changes. The below message is current for MPlayer 1.0rc4.
MPLAYER_WARN_BFRAMES_TEXT="Invalid and inefficient vfw-avi packed B frames detected"

# When testing under the GNU system this is needed to help ensure that
# this script will work under more strict POSIX-compliant systems (e.g.
# commercial UNIXes).
export POSIXLY_CORRECT=1

print_help()
{
    cat <<EOF
Usage: $PROGNAME AVIFILE...
Checks a list of AVI files for DivX Home Theatre compliance.
EOF
}

print_try_help()
{
    echo "Try \`$PROGNAME -h' for more information." >&2
}

assert_have_program()
{
    local prog
    for prog in $*; do
        if ! which $prog >/dev/null 2>&1; then
            echo "$PROGNAME: error: program \`$prog' is needed in the system path to run this script." >&2
            exit 1
        fi
    done
}

# $1 = video file name
# Returns zero exit status if success; non-zero if failure.
# Returns video parameters stored in shell variables
#   ID_VIDEO_ID: Video stream identifier number
#   ID_AUDIO_ID: Audio stream identifier number
#   ID_CLIP_INFO_N: Number of clip info entries; entries are indexed from zero to N-1.
#   ID_CLIP_INFO_NAME<n>: Description of clip info field, loosely defined but human readable.
#       (e.g. "Software" typically corresponds to encoding software used).
#   ID_CLIP_INFO_VALUE<n>: Value of clip info field n.
#   ID_FILENAME: File name of file being probed.
#   ID_DEMUXER: Container format, should normally be "avi" for AVI files.
#   ID_VIDEO_FORMAT: FourCC of video stream, e.g. "DX50".
#   ID_VIDEO_BITRATE: Bitrate of video stream, in bits per second (integer).
#   ID_VIDEO_WIDTH: Pixel width of video stream.
#   ID_VIDEO_HEIGHT: Pixel height of video stream.
#   ID_VIDEO_FPS:
#       Frame rate (frames per second) of video stream, in decimal. May
#       be zero for certain container formats that have variable frame
#       rates (frames are indexed by millisecond-resolution timestamps
#       instead), such as WMV, ASF and MPEG-4.
#   ID_VIDEO_ASPECT: Aspect ratio (width/height) expressed as decimal.
#       In some cases this may be zero (if it's not recorded anywhere in the file).
#   ID_VIDEO_CODEC: Codec MPlayer has selected to decode video stream
#       (should use "ffodivx" for DivX 5, "ffdivx" for DivX 3)
#   ID_AUDIO_FORMAT:
#       An integer (internal to MPlayer) describing the audio stream format:
#           80      MPEG-1 Layer II audio (aka "mp2")
#           85      MPEG-1 Layer III audio (aka "mp3")
#           8192    Dolby AC-3
#   ID_AUDIO_BITRATE: Audio stream bitrate in bits per second (integer).
#   ID_AUDIO_RATE: Sampling rate of audio stream (audio frames per second).
#       May be zero if unavailable.
#   ID_AUDIO_NCH: Number of channels in audio stream, may be zero if unavailable.
#   ID_AUDIO_CODEC: Codec MPlayer has selected to decode audio stream
#       "mp3" for MPEG-1 layer II/III audio
#       "ffac3" for Dolby AC-3
#   ID_LENGTH: Total playback duration of file, in seconds (decimal).
#   ID_EXIT: Shows reason for MPlayer exiting
#       "EOF": End of file (or requested playback range) reached
#       "QUIT": User manually exited.
#       "ERROR": Error occurred (e.g. format unrecognised)
#       "NONE": Cause unknown.
mplayer_identify()
{
    unset ID_EXIT
    if ! [ -e "$1" ]; then
        echo "$PROGNAME: error: cannot find file \`$1'" >&2
        return 1
    elif ! [ -f "$1" ]; then
        echo "$PROGNAME: error: \`$1' is not a file" >&2
        return 1
    fi
    # Note: the aspect ratio does not become available until we play at least 1 frame
    eval `mplayer -noconfig all -cache-min 0 -identify -really-quiet -vo null -ao null -frames 1 "$1" 2>/dev/null \
        | sed '/^\w\+=/!d; s/\([^-[:alnum:]=_.:/+@,^]\)/\\\\\1/g'`
    if [ "$ID_EXIT" != EOF ]; then
        echo "$PROGNAME: error: unable to retrieve information for file \`$1'" >&2
        return 1
    fi
}

# Template used for temporary files
MKTEMP_TEMPLATE=/tmp/divxhtcheck.XXXXXX
# Named pipe used to send statements to POSIX bc co-process
BC_STMT_PIPE=
# Named pipe used to read results back from POSIX bc co-process
BC_RSLT_PIPE=
# PID of bc co-process (in case it needs to be killed)
BC_PID=

# Starts a background POSIX bc co-process that can receive input and
# return output via the file descriptors 4 and 5 respectively.
# Terminates the script with an error message if the bc program cannot
# be launched in this manner.
bc_start()
{
    if ! BC_STMT_PIPE=`mktemp $MKTEMP_TEMPLATE`; then
        echo "$PROGNAME: error: unable to create temporary file \`$MKTEMP_TEMPLATE'" >&2
        exit 1
    elif ! BC_RSLT_PIPE=`mktemp $MKTEMP_TEMPLATE`; then
        echo "$PROGNAME: error: unable to create temporary file \`$MKTEMP_TEMPLATE'" >&2
        exit 1
    fi
    rm -f $BC_STMT_PIPE $BC_RSLT_PIPE
    if ! mkfifo -m600 $BC_STMT_PIPE $BC_RSLT_PIPE; then
        echo "$PROGNAME: error: unable to create temporary named pipes" >&2
        exit 1
    fi
    bc -q <$BC_STMT_PIPE >$BC_RSLT_PIPE &
    BC_PID=$!
    if ! exec 4>$BC_STMT_PIPE 5<$BC_RSLT_PIPE; then
        echo "$PROGNAME: error: unable to communicate with \`bc' child process" >&2
        exit 1
    fi
    rm -f $BC_STMT_PIPE $BC_RSLT_PIPE
}

# Sends a line of input asynchronously to the POSIX bc co-process. Each
# argument is sent as an individual line. Any results that these
# statements might produce can be read back through bc_read_result.
bc_run_cmds()
{
    local arg
    for arg; do
        echo "$arg" >&4
    done
}

# Reads back one or more lines of output from the POSIX bc co-process.
# Each argument contains the name of a shell variable that successive
# lines read back will be stored in. Be careful not to specify more
# arguments than there are lines pending, otherwise deadlock will occur.
bc_read_result()
{
    local arg
    for arg; do
        read $arg <&5
    done
}

# Performs a relational operator test using the POSIX bc co-process. The
# first and only argument must consist of the form "x OP y", where x and
# y are real numbers or single-letter bc variables, and OP is one of the
# relational operators ==, <, >, !=, <= or >=. Return status is zero if
# the expression evalutes as true, or non-zero if expression evaluated
# as false.
bc_run_test()
{
    local res;
    echo -e "if($1) { \"true\"; }; \"\n\""  >&4
    read res <&5
    [ "$res" = true ] && return 0;
    return 1;
}

# Terminates the POSIX bc co-process.
bc_end()
{
    exec 4>&- 5<&-
    wait $BC_PID
}

# Tests if a file is DivX Home Theatre compliant
# $1 = file to test
# Returns zero exit status if compliant; non-zero otherwise.
# Messages will be printed to standard error explaining any failures.
divxht_test()
{
    local failed
    failed=0

    # Confirm AVI file extension
    if [ `expr match "$1" '.*\.[Aa][Vv][Ii]$'` -eq 0 ]; then
        echo "$PROGNAME: failure: \`$1' does not have file extension \`.avi'" >&2
        return 1
    fi

    if [ `expr match "${1##*/}" '.*\.[Aa][Vv][Ii]$'` -gt 60 ]; then
        echo "$PROGNAME: failure: \`$1' file name is longer than 64 characters" >&2
        return 1
    fi

    if ! mplayer_identify "$1"; then
        return 1
    fi

    # Confirm AVI container
    if [ "$ID_DEMUXER" != avi ]; then
        echo "$PROGNAME: failure: \`$1' is not in avi container format: $ID_DEMUXER" >&2
        failed=1
    fi

    # Confirm video FourCC is "DX50", "DIVX", "XVID" or "DIV3"
    if [ "$ID_VIDEO_FORMAT" != DX50 \
        -a "$ID_VIDEO_FORMAT" != DIVX \
        -a "$ID_VIDEO_FORMAT" != XVID \
        -a "$ID_VIDEO_FORMAT" != DIV3 ]; then
        echo "$PROGNAME: failure: \`$1' video fourcc is not \`DX50', \`DIVX', \`XVID' or \`DIV3': $ID_VIDEO_FORMAT" >&2
        failed=1
    fi

    # Confirm video stream is DivX 3/5
    if [ "$ID_VIDEO_CODEC" != $VIDCODEC_DIVX5 -a "$ID_VIDEO_CODEC" != $VIDCODEC_DIVX3 ]; then
        echo "$PROGNAME: failure: \`$1' video stream is not DivX format: $ID_VIDEO_CODEC" >&2
        failed=1
    fi

    # Confirm video bitrate does not exceed 4Mbps
    if [ $ID_VIDEO_BITRATE -gt 4000000 ]; then
        echo "$PROGNAME: failure: \`$1' video bitrate exceeds 4Mbps: $ID_VIDEO_BITRATE" >&2
        failed=1
    fi

    # Confirm video pixel width does not exceed 720
    if [ $ID_VIDEO_WIDTH -gt 720 ]; then
        echo "$PROGNAME: failure: \`$1' video pixel width exceeds 720: $ID_VIDEO_WIDTH" >&2
        failed=1
    fi

    # Confirm frame rate does not exceed 30fps
    if bc_run_test "$ID_VIDEO_FPS > 30"; then
        echo "$PROGNAME: failure: \`$1' frame rate exceeds 30fps: $ID_VIDEO_FPS" >&2
        failed=1
    fi

    # Video pixel height check
    if bc_run_test "$ID_VIDEO_FPS > 25"; then
        # Must not exceed 480 if 25 < fps <= 30 (NTSC)
        if [ $ID_VIDEO_HEIGHT -gt 480 ]; then
            echo "$PROGNAME: failure: \`$1' video pixel height exceeds 480 for NTSC mode: $ID_VIDEO_HEIGHT" >&2
            failed=1
        fi
    else
        # Must not exceed 576 if fps <= 25 (PAL)
        if [ $ID_VIDEO_HEIGHT -gt 576 ]; then
            echo "$PROGNAME: failure: \`$1' video pixel height exceeds 576 for PAL mode: $ID_VIDEO_HEIGHT" >&2
            failed=1
        fi
    fi

    # Check if audio stream format is recognised
    if [ $ID_AUDIO_FORMAT -ne $AUDF_MPEG1_LAYER_II \
            -a $ID_AUDIO_FORMAT -ne $AUDF_MPEG1_LAYER_III \
            -a $ID_AUDIO_FORMAT -ne $AUDF_DOLBY_AC3 ]; then
        # Unrecognised audio format
        echo "$PROGNAME: failure: \`$1' audio format is unrecognised: $ID_AUDIO_FORMAT ($ID_AUDIO_CODEC)" >&2
        failed=1
    fi

    # Warn if aspect ratio is missing
    if bc_run_test "$ID_VIDEO_ASPECT == 0"; then
        echo "$PROGNAME: warning: \`$1' does not have a video aspect ratio specified."\
" Most DivX-HT hardware players will assume square pixels, which might not be what was intended." >&2
    fi

    # Check if DivX MPEG-4 stream contains multiple consecutive
    # bi-directional predictive frames (B-frames); this is a violation
    # of the DivX 5 HT spec, and most hardware players (such as the
    # Panasonic NV-VP60) won't decode these frames, resulting in jerky
    # motion.
    # 
    # MPlayer produces a warning message when they are encountered. The
    # only way we can detect these frames is to play back a brief
    # portion of the movie and monitor MPlayer's diagnostic output.
    if mplayer -vo null -ao null -frames 1 -benchmark -quiet "$1" 2>&1 \
        | grep -q "$MPLAYER_WARN_BFRAMES_TEXT"; then
        echo "$PROGNAME: failure: \`$1' contains multiple consecutive B-type frames and must be re-encoded" >&2
        failed=1
    fi

    # Check if OpenDML index would cause problems
    file_size=`wc -c "$1" | sed 's/^[[:blank:]]*\([0-9]\+\).*$/\1/'`
    if bc_run_test "$file_size > 1073741824"; then
        # If file is >= 1GB, it must not contain an OpenDML index,
        # otherwise playback on the Panasonic NV-VP60 will experience
        # major problems when the 1GB boundary is trangressed (A-V
        # desync, loss of audio or premature end of playback). MEncoder
        # without the -noodml option normally starts a new RIFF chunk at
        # every 1GB mark, so the cause seems to be that the NV-VP60 only
        # understands the first RIFF chunk of the file.
        #
        # Scan first 8kB of AVI file for a "dmlh" chunk (OpenDML header)
        # FIXME: A better approach would be to decode the AVI structure and
        # look for multiple RIFF chunks? May be difficult in Bourne Shell.
        if dd if="$1" bs=8192 count=1 2>/dev/null | strings -a -T binary | grep -q odmldmlh; then
            echo "$PROGNAME: failure: \`$1' exceeds 1GB and contains an OpenDML index" >&2
            failed=1
        fi
    fi

    return $failed
}

while getopts "h" opt; do
    case $opt in
        'h') print_help; exit 0;;
        '?') print_try_help; exit 1;;
    esac
done
shift $(($OPTIND-1))

assert_have_program bc mplayer mkfifo
bc_start

exit_status=0
for file; do
    if ! divxht_test "$file"; then
        exit_status=1
    fi
done

bc_end

exit $exit_status
